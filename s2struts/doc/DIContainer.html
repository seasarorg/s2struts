<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- don't edit start -->
<head>
<title>Seasar - DI Container with AOP - </title>
<META http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<META name="GENERATOR" content="IBM WebSphere Studio Homepage Builder Version 8.0.0.0 Trial for Windows">
<META http-equiv="Content-Style-Type" content="text/css">
<link href="seasar_b.css" type="text/css" rel="stylesheet"><script src="seasar_b.js" type="text/JavaScript" language="JavaScript"></script>
</head><body onload="preload('ja')"><table width="100%" border="0" cellspacing="0" cellpadding="0" align="left" height="100%"><tr>
<td align="left" valign="top" width="780"><table width="780" border="0" cellspacing="0" cellpadding="0" class="white">
<tr><td colspan="7"><img height="5" width="780" src="images/top01_b.gif" alt=""></td></tr>
<tr><td width="235"><img height="117" width="235" src="images/top02_b.gif" alt="Seasar"></td>
<td colspan="3"><img height="117" width="289" src="images/top03.gif" alt="DI Container with AOP"></td>
<td colspan="3"><img height="117" width="256" src="images/spacer.gif" alt=""></td>
</tr><tr><td rowspan="2"><img src="images/top04.gif" alt="" height="49" width="235"></td>
<td width="78"><a href="index.html"><img src="images/menu01_b_ja.gif" height="30" width="78" border="0" alt="" id="menu01" onmouseover="swap(1)" onmouseout="restore(1)"></a></td>
<td width="101"><a href="http://sourceforge.jp/projects/seasar"><img src="images/menu02_b_ja.gif" height="30" width="101" border="0" alt="" id="menu02" onmouseover="swap(2)" onmouseout="restore(2)"></a></td>
<td width="110"><a href="download.html"><img src="images/menu03_b_ja.gif" height="30" width="110" border="0" alt="" id="menu03" onmouseover="swap(3)" onmouseout="restore(3)"></a></td>
<td width="113"><a href="document.html"><img src="images/menu04_b_ja.gif" height="30" width="113" border="0" alt="" id="menu04" onmouseover="swap(4)" onmouseout="restore(4)"></a></td>
<td width="109"><a href="resource.html"><img src="images/menu05_b_ja.gif" height="30" width="109" border="0" alt="" id="menu05" onmouseover="swap(5)" onmouseout="restore(5)"></a></td>
<td width="34"><img height="30" width="34" src="images/menu06.gif" alt=""></td></tr><tr>
<td colspan="6"><img height="19" width="545" src="images/spacer.gif" alt=""></td></tr></table>
<table  width="780" border="0" cellspacing="0" cellpadding="0" height="100%" class="white">
<tr align="left" valign="top"><td width="18"><img height="14" width="18" src="images/spacer.gif" alt=""></td><td width="744" class="main">
<!-- don't edit end -->
<!-- document start -->
            <ul>
              <li><a href="#S2Container">S2Container概要</a>
                <ul>
                  <li><a href="#DifferentPoint">今までと何が違うのか</a></li>
                  <li><a href="#S2Merit">何がうれしいのか</a></li>
                </ul>
              </li>

              <li><a href="#S2ContainerReference">S2Containerリファレンス</a>
                <ul>
                  <li><a href="#CreateFile">作成すべきファイル</a></li>
                  <li><a href="#S2ContainerDefinition">S2Containerの定義</a></li>
                  <li><a href="#S2ContainerCreation">S2Containerの生成</a></li>
                  <li><a href="#getComponent">コンポーネントの取得</a></li>
                  <li><a href="#DIType">Dependency Injectionのタイプ</a>
                    <ul>
                      <li type="circle"><a href="#ConstructorInjection">コンストラクタ・インジェクション</a></li>
                      <li type="circle"><a href="#SetterInjection">セッター・インジェクション</a></li>
                      <li type="circle"><a href="#MethodInjection">メソッド・インジェクション</a></li>
                    </ul>
                  </li>
                  <li><a href="#Include">S2Container定義の分割とインクルード</a></li>
                  <li><a href="#Namespace">名前空間</a></li>
                  <li><a href="#InstanceMode">インスタンス管理</a></li>
                  <li><a href="#Lifecycle">ライフサイクル</a></li>
                  <li><a href="#AutoBindingMode">自動バインディング</a></li>
                  <li><a href="#UseS2Container">コンポーネントでS2Containerを利用する</a></li>
                  <li><a href="#S2ContainerServlet">S2ContainerServlet</a></li>
                  <li><a href="#app.dicon">app.diconの役割</a></li>
                  <li><a href="#Aop">AOPの適用</a></li>
				  <li><a href="#Meta">メタデータ</a></li>
				  <li><a href="#Request">Requestの自動バインディング</a></li>
                </ul>
              </li>
              <li><a href="#DefReference">S2Container定義タグリファレンス</a>
                <ul>
                  <li><a href="#DOCTYPE">DOCTYPE</a></li>
                  <li><a href="#componentsTag">componentsタグ</a></li>
                  <li><a href="#includeTag">includeタグ</a></li>
                  <li><a href="#componentTag">componentタグ</a></li>
                  <li><a href="#argTag">argタグ</a></li>
                  <li><a href="#propertyTag">propertyタグ</a></li>
				  <li><a href="#metaTag">metaタグ</a></li>
                  <li><a href="#initMethodTag">initMethodタグ</a></li>
                  <li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
                  <li><a href="#aspectTag">aspectタグ</a></li>
                  <li><a href="#descriptionTag">descriptionタグ</a></li>
                  <li><a href="#ognlExpr">OGNL式</a></li>
                </ul>
              </li>
              <li><a href="#Example">Example</a>
                <ul>
                  <li><a href="#ConstructorInjectionEx">コンストラクタ・インジェクション</a></li>
                  <li><a href="#SetterInjectionEx">セッター・インジェクション</a></li>
                  <li><a href="#MethodInjectionEx">メソッド・インジェクション</a></li>
                  <li><a href="#AutoConstructorInjectionEx">自動バインディング(コンストラクタ・インジェクション)</a></li>
                  <li><a href="#AutoSetterInjectionEx">自動バインディング(セッター・インジェクション)</a></li>
                </ul>
              </li>
            </ul>

            <a name="S2Container"><h2>S2Containerの概要</h2></a>
            <p>S2Containerでは、DIContainer機能を提供しています。DIContainerとは、Dependency Injectionをおこなう軽量コンテナです。Dependency Injectionとは、インターフェースと実装を分離してコンポーネント同士がインターフェースのみで会話するようにし、実際のコンポーネントの生成や設定を、外出しにしようという考え方です。Dependency Injectionについては<A href="http://www.kakutani.com/trans/fowler/injection.html">Martin Fowler の「Inversion of Control Containers and the Dependency Injection pattern」</A>で分かりやすく説明されています。コンポーネントとは、ここではJavaのクラスのことをいいます。複数のコンポーネントを格納・管理しているのでコンテナと呼び、軽量は、EJBのコンテナなどと比べ手軽に使えるという意味です。
            </p><p>DIContainerのイメージは、次のようになります。</p>

	<IMG src="images/container01.gif" border="0">

            <p>図のようにDIContainerに対して要求すると、DIContainerはコンテナ内を検索してインターフェースに関連したコンポーネント(実装クラス)のインスタンスを返します。インターフェースとコンポーネントの関連づけは、自動でDIContainerが行います。コンポーネントのコンテナ登録は、設定ファイルを定義するだけで簡単にできます。DIContainerが、コンポーネントの管理・設定を行ってくれるためプログラムはインターフェースのみを意識することになります。実際に図中のインターフェース(Hoge)とコンポーネント(HogeImpl)の要求・取得をプログラムで表すと、次のようになります。</p>
            
<pre>
public interface Hoge {

    public void showMessage();
}
</pre>

<pre>
public class HogeImpl implements Hoge {

    public void showMessage() {
        System.out.println(&quot;Hello World!&quot;);
    }
}
</pre>

<p>インターフェースでは showMessage()を定義し、実装クラスでは、showMessage()で&quot;Hello World!&quot;を表示しています。</p>

<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.HogeImpl&quot;/&gt;
&lt;/components&gt;
</pre>

<p>コンポーネントをコンテナに登録する定義は、これだけです。詳しい定義方法は、<a href="#S2ContainerDefinition">S2Containerの定義</a>を参照してください。次は、実行クラス(インターフェースと会話をする部分)です。</p>

<pre>
public class HelloClient {

    private static String PATH = &quot;examples/dicon/Hello.dicon&quot;;
	
    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        Hoge hoge = (Hoge) container.getComponent(Hoge.class);
        hoge.showMessage();
    }
}
</pre>

<p>実装クラス(HogeImpl)が登場していないことから、使う側はインターフェースのみを意識すればよいということがわかると思います。S2Containerの詳しい使用方法は、<a href="#S2ContainerReference">S2Containerリファレンス</a>を参照してください。</p>



            <a name="DifferentPoint"><h3>今までと何が違うのか</h3></a>
            <p>コンポーネント同士がインターフェースのみで会話することにより依存関係をなくすという考え方は、従来からオブジェクト指向の世界にありました。しかし、開発時にインターフェースのみで依存関係をなくすように設計しても、完成までにはソースコードのどこかに依存関係を記述する必要がありました。その依存関係をDIContainerを用いて、実行時に外から組み立てるという考え方が今までと違う点です。</p>
            <a name="S2Merit"><h3>何がうれしいのか</h3></a>
            <p>DIContainerのメリットには次の点が挙げられます。</p>
              <ul>
                <li>メンテナンス性の向上<br/>- 実装クラス同士の依存度が下がるため後からロジックを変更してもその影響範囲を極小化できます。</li>
                <li>品質の向上<br/>- モックを使って簡単にテストできるようになるためテスタビリティが向上します。</li>
                <li>開発期間の短縮<br/>- 使いたい機能の実装が出来上がってなくても実装・テストをおこなえるため並行して作業できるようになります。</li>
                <li>再利用性の向上<br/>- コンポーネントは通常のJavaのクラス(POJO)であり特定のAPI(EJBなど)に依存しないので再利用できる機会が増えます。</li>
              </ul>

            <a name="S2ContainerReference"><h2>S2Containerリファレンス</h2></a>

            <a name="CreateFile"><b><h3>作成すべきファイル</h3></b></a>
            <p>S2Containerを使用するためには、定義ファイルを作成する必要があります。<br/>定義ファイルは、コンポーネントを組み立てるための設計書のようなものです。<br/>形式はXMLで、拡張子は、diconです。diconは、ダイコンと読みます。</p>

            <a name="S2ContainerDefinition"><b><h3>S2Containerの定義</h3></b></a>
            <p>S2Containerの定義は、次のようになります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <p>DOCTYPEは省略できません。diconファイルを作成する場合は、上記のサンプルをコピー＆ペーストしてください。ルートは<a href="#componentsTag">componentsタグ</a>です。コンポーネントごとに、<a href="#componentTag">componentタグ</a>を定義していきます。componentタグのclass属性でコンポーネントのクラスの完全限定名を指定します。name属性には、コンポーネント名を指定します。詳細は、<a href="#DefReference">S2Container定義タグリファレンス</a>を参照してください。</p>


<pre>
&lt;components&gt;
    &lt;component name=&quot;hoge&quot; class=&quot;examples.dicon.HogeImpl&quot;/&gt;
&lt;/components&gt;
</pre>


            <a name="S2ContainerCreation"><h3>S2Containerの生成</h3></a>
            <p>S2Containerを作成する場合は、次のメソッドを使用します。</p>
            <p>- org.seasar.framework.container.factory.S2ContainerFactory#create(String path)</p>
            引数pathはCLASSPATHで指定されているディレクトリをルートとする設定ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon になります。セパレータは、WindowsでもUnixでも/です。
<pre>
private static final String PATH = "aaa/bbb/ccc.dicon";
...
S2Container container = S2ContainerFactory.create(PATH);
</pre>


            <a name="getComponent"><h3>コンポーネントの取得</h3></a>
            <p>S2Containerからコンポーネントを取り出すには、次のメソッドを使用します。</p>
            <p>- org.seasar.framework.container.S2Container#getComponent(Object componentKey)</p>
            引数には、コンポーネントのクラスもしくはコンポーネント名を指定できます。詳しくは、<a href="#componentTag">componentタグ</a>を参照してください。コンポーネントのクラスを指定する場合、コンポーネント instanceof クラスがtrueを返すクラスなら指定することができます。しかし、S2Containerの中に指定したクラスを実装しているコンポーネントが複数ある場合、S2Containerは、どのコンポーネントを返せばよいのか判断できないため、TooManyRegistrationRuntimeExceptionが発生します。実装コンポーネントがユニークに決まるクラスを指定してください。コンポーネント名で取得することもできます。その場合も、同一の名前をもつコンポーネントが複数登録されている場合、TooManyRegistrationRuntimeExceptionが発生します。コンポーネント名指定の場合、スペルミスをする可能性もあるので、できるだけクラス指定のほうが良いでしょう。<br/><br/>

            <p>例） クラスを指定してコンポーネントを取得する場合</p>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent(Hoge.class);
</pre>

            <p>例） コンポーネント名を指定してコンポーネントを取得する場合</p>
<pre>
S2Container container = S2ContainerFactory.create(PATH);
Hoge hoge = (Hoge) container.getComponent("hoge");
</pre>

            <a name="DIType"><h3>Dependency Injectionのタイプ</h3></a>
            <p>Dependency Injectionには、コンポーネントの構成に必要な値をコンストラクタで設定する(Constructor Injection)のか、セッター・メソッドで設定する(Setter Injection)のか、初期化メソッドで設定する(Method Injection)のかで、タイプが分かれます。Method InjectionはS2のオリジナルです。S2はすべてのタイプとそのハイブリッド型もサポートします。</p>

            <a name="ConstructorInjection"><b><h3>コンストラクタ・インジェクション</h3></b></a>
            <p>コンストラクタ・インジェクションとは、任意のコンストラクタの引数値にDependency Injectionします。<br/>S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントは、componentタグで組み立てます。class属性でクラス名を指定します。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>コンストラクタの引数の指定</b><br/>コンポーネントのコンストラクタの引数は、componentタグの子タグであるargタグを使って指定します。<br/>文字列の場合は、ダブルコーテーション(")で囲みます。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            詳しい使用方法は、Exampleの<a href="#ConstructorInjectionEx">コンストラクタ・インジェクション</a>を参照してください。<br/><br/>

            <a name="SetterInjection"><b><h3>セッター･インジェクション</h3></b></a>
            <p>セッター･インジェクションとは、任意のプロパティにセッターメソッドを使用してDependency Injectionします。<br/>S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>プロパティの指定</b><br/>コンポーネントのプロパティは、componentタグの子タグであるpropertyタグを使って指定します。<br/>name属性でプロパティ名を指定します。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;property name=&quot;...&quot;&gt;...&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            詳しい使用方法は、Exampleの<a href="#SetterInjectionEx">セッター･インジェクション</a>を参照してください。<br/>

            <a name="MethodInjection"><b><h3>メソッド・インジェクション</h3></b></a>
            <p>メソッド・インジェクションとは、任意のメソッドを呼び出して、Dependency Injectionします。<br/>S2Containerの定義ファイルには、次の内容を記述します。</p>
         <ul>
            <li><b>コンポーネントの指定</b><br/>コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br/>name属性でコンポーネントに名前を付けることもできます。</li>
            <li><b>初期化メソッドの指定</b><br/>initMethodタグを使って、コンポーネントの任意のメソッドを呼び出します。name属性で、メソッド名を指定します。引数は、argタグを子タグに使います。name属性を省略して、ボディで、<a href="#ognlExpr">OGNL式</a>を使うこともできます。その際、コンポーネント自身は#selfで表します。</li>
         </ul>

<pre>
&lt;components&gt;
    &lt;component name=&quot;...&quot; class=&quot;...&quot;&gt;
          &lt;initMethod&gt;...&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            詳しい使用方法は、Exampleの<a href="#MethodInjectionEx">メソッド・インジェクション</a>を参照してください。<br/>
         
            <a name="Include"><h3>S2Container定義の分割とインクルード</h3></a>
            <p>すべてのコンポーネントを1つのファイルに記述すると、直ぐに肥大化してしまい管理が難しくなります。そのため、コンポーネントの定義を複数に分割する機能と分割された定義をインクルードして1つにまとめる機能がS2Containerにあります。S2Container定義ファイルのインクルードは次のようにして行います。</p>

<pre>&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p><a href="#includeTag">includeタグ</a>のpath属性で取り込みたいS2Container定義ファイルのパスを指定します。詳しくは、<a href="#includeTag">includeタグ</a>を参照してください。<br/>コンポーネントの検索順は、先ず自分自身に登録されているコンポーネントを探して、見つからない場合は、includeされている順に子供のS2Containerに登録されているコンポーネントを検索し、最初に見つかったコンポーネントが返されます。<br/>次のような場合は、Foo(自身のコンポーネント)→aaa(子供のS2Container)→bbb(子供のS2Container)の順に検索します。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;aaa.dicon&quot;/&gt;
    &lt;include path=&quot;bbb.dicon&quot;/&gt;
    &lt;component class=&quot;example.container.Foo&quot; /&gt;
&lt;/components&gt;
</pre>

            <p>自動で<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>や<a href="#SetterInjection">セッター・インジェクション</a>を行う場合、S2Containerはインクルード先のコンポーネントを自動インジェクションすることができます。自動でDependency Injectionを行う場合の条件は<a href="#AutoBindingMode">自動バインディング</a>を参照してください。<br/>次のようにセッター･インジェクションでプロパティに指定するコンポーネントがインクルード先のaaa.diconとbbb.diconに登録されている場合、各HelloClientでは、どちらのコンポーネントが使用されるかをみてましょう。</p>

            <h5>root.dicon</h5>
<pre>
&lt;components&gt;
    &lt;include path=&quot;examples/dicon/include/aaa.dicon&quot;/&gt;
    &lt;include path=&quot;examples/dicon/include/bbb.dicon&quot;/&gt;
    &lt;component name=&quot;root&quot; class=&quot;examples.dicon.include.RootHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>aaa.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.include.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Aaa!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;aaa&quot; class=&quot;examples.dicon.include.AaaHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>
 
            <h5>bbb.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.include.HelloImpl&quot;&gt;
        &lt;property name=&quot;Message&quot;&gt;&quot;Hello Bbb!&quot;&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name=&quot;bbb&quot; class=&quot;examples.dicon.include.BbbHelloClient&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>各コンポーネントの内容は、次のようになります。</p>

<pre>
package examples.dicon.include;

public interface HelloClient {

    public void showMessage();
}
</pre>

<pre>
package examples.dicon.include;

public class RootHelloClient implements HelloClient {

    private Hello hello_;

    public void setHello(Hello hello) {
        hello_ = hello;
    }

    public Hello getHello() {
        return hello_;
    }

    public void showMessage() {
        System.out.println(getHello().getMessage());
    }
}
</pre>

            <p>AaaHelloClientとBbbHelloClientはRootHelloClient同様の実装です。</p>

<pre>
package examples.dicon.include;

public interface Hello {

    public void setMessage(String helloMessage);

    public String getMessage();
}
</pre>

<pre>
package examples.dicon.include;

public class HelloImpl implements Hello {

    private String helloMessage_;

    public void setMessage(String helloMessage) {
        helloMessage_ = helloMessage;
    }

    public String getMessage() {
        return helloMessage_;
    }
}
</pre>

           <p>HelloImplはMessageプロパティを定義しているだけです。各HelloClientのshowMessage()を呼び出した場合の実行結果は次のようになります。</p>
           
           <h5>RootHelloClientの実行結果</h5>
<pre>
Hello Aaa!
</pre>
           <p>まず、S2Containerはroot.diconにHelloImplが登録されているかを検索します。root.diconにはないので、次にインクルード先のaaa.diconを検索します。aaa.diconにはHelloImplが登録されているので、そのコンポーネントを使用します。</p>

           <h5>AaaHelloClientの実行結果</h5>
<pre>
Hello Aaa!
</pre>

           <p>AaaHelloClientは、aaa.diconに登録されているコンポーネントを使用します。自動でインジェクションを行う場合、子供のS2Containerは親のS2Containerのコンポーネントを使用することはできません。例えば、root.diconにHelloImplを登録していてもAaaHelloClientには自動インジェクションされないということです。</p>

           <h5>BbbHelloClientの実行結果</h5>
<pre>
Hello Bbb!
</pre>

           <p>AaaHelloClientと同様にBbbHelloClientもbbb.diconに登録されているコンポーネントを使用します。<br/>このサンプルは、seasar2/src/examples/dicon/include以下に用意されています。</p>

            <a name="Namespace"><h3>名前空間</h3></a>
            <p>コンポーネントの定義を分割した場合に、複数のコンポーネント定義間で名前が衝突しないように、<a href="#componentsTag">componentsタグ</a>のnamespace属性で名前空間を指定することができます。</p>
            <h5>foo.dicon</h5>
<pre>
&lt;components namespace=&quot;foo&quot;&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>bar.dicon</h5>

<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;include path=&quot;foo.dicon&quot;/&gt;
    &lt;component name=&quot;aaa&quot; .../&gt;
    &lt;component name=&quot;bbb&quot; ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name=&quot;ccc&quot; ...&gt;
        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>app.dicon</h5>

<pre>
&lt;components&gt;
    &lt;include path=&quot;bar.dicon&quot;/&gt;
&lt;/components&gt;
</pre>

            <p>同一のコンポーネント定義内では、名前空間なしで参照できます。他のS2Container定義のコンポーネントを参照する場合は、名前空間.をコンポーネント名の頭につけます。foo.aaaとbar.aaaは同じ名前がついていますが、名前空間が異なっているので、違うコンポーネントとして認識されます。慣習として、定義ファイルの名前は、名前空間.diconにすることを推奨します。</p>

<a name="InstanceMode"><h3>インスタンス管理</h3></a>
            <p>S2Containerで、コンポーネントのインスタンスをどのように管理するのかを指定するのが、<a href="#componentTag">componentタグ</a>のinstance属性です。デフォルトはsingletonで、これは、S2Container.getComponent()によって返されるコンポーネントは常に同じだという意味です。S2Container.getComponent()を呼び出すたびに、新たに作成されたコンポーネントを返して欲しい場合は、instance属性にprototypeを指定します。リクエスト(HttpServletRequest)ごとにコンポーネントを管理したい場合は、instance属性にrequestを指定します。セッション(HttpSession)ごとにコンポーネントを管理したい場合は、instance属性にsessionを指定します。</p>
            <p>プレゼンテーションのフレームワークと組み合わせるときに、プレゼンテーションフレームワークが作成したインスタンスに対して、S2Containerで管理されているコンポーネントをセットしたい場合があります。そのようなS2Container外のコンポーネントに対して<a href="http://www.kakutani.com/trans/fowler/injection.html">Dependency Injection</a>したいときには、次のメソッドを使用します。<br/><br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent)<br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent, Class componentClass)<br/>- org.seasar.framework.container.S2Container#injectDependency(Object outerComponent, String componentName)</p>
            第一引数には、外部のコンポーネントを指定します。第二引数には、外部コンポーネントのクラス、またはコンポーネント名を指定します。<br/>そのとき、S2Container定義では、instance属性にouterを指定します。

<table width="744" border="1">
  <tr bgcolor="#d1f3f4" align="center">
    <th width="104" scope="col">instance属性</th>
    <th width="624" scope="col">説明</th>
  </tr>
  <tr>
    <td>singleton(default)</td>
    <td>S2Container.getComponent()を何度呼び出しても同じインスタンスが返されます。</td>
  </tr>
  <tr>
    <td>prototype</td>
    <td>S2Container.getComponent()を呼び出すたびに新たなインスタンスが返されます。</td>
  </tr>
  <tr>
<td>request</td>
<td>リクエスト毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがリクエストに格納されます。</td>
</tr>
<tr>
<td>session</td>
<td>セッション毎に1つのインスタンスが作成されます。name属性に指定した名前で、コンポーネントがセッションに格納されます。</td>
</tr>
<tr>
  <td>outer</td>
  <td>コンポーネントのインスタンスは、S2Container外で作成し、Dependency Injectionだけを行います。<a href="#Aop">アスペクト</a>、<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>は適用できません。</td>
</tr>
</table>

            <a name="Lifecycle"><h3>ライフサイクル</h3></a>
            <p>initMethodやdestroyMethodでコンポーネントのライフサイクルもコンテナで管理することができます。S2Containerの開始時(S2Container.init())に<a href="#initMethodTag">initMethodタグ</a>で指定したメソッドが呼び出され、S2Containerの終了時(S2Container.destroy())に<a href="#destroyMethodTag">destroyMethodタグ</a>で指定したメソッドが呼び出されるようになります。initMethodはコンポーネントがコンテナに登録した順番に実行され、destroyMethodはその逆順に呼び出されることになります。instance属性がsingleton以外の場合、destroyMethodを指定しても無視されます。java.util.HashMap#put()メソッドに初期化(aaaに111を設定)・終了処理(aaaにnullを設定)を設定する場合は、次のようになります。</p>
<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;component name=&quot;map&quot; class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;null&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <a name="AutoBindingMode"><h3>自動バインディング</h3></a>
            <p>コンポーネント間の依存関係は、型がインターフェースの場合、コンテナによって自動的に解決されます。これがS2Containerのデフォルトですが、<a href="#componentTag">componentタグ</a>のautoBinding属性を指定することで細かく制御することもできます。</p>

<table width="744" border="1">
<tr bgcolor="#d1f3f4" align="center">
<th width="104" scope="col">autoBinding</th>
<th width="624" scope="col">説明</th>
</tr>
<tr>
<td>auto(default)</td>
<td>

<p>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
指定されていない場合、引数のないデフォルトコンストラクタが定義されている場合はそのコンストラクタを使います。<br/>
デフォルトのコンストラクタがない場合、コンストラクタの引数の数が1以上で、引数の型がすべてインターフェースのコンストラクタで最も引数の数が多いものを使います。<br/>
プロパティが明示的に指定されている場合はそれに従います。<br/>
明示的に指定されていないプロパティで、型がインターフェースの場合は自動的にバインドします。</p>
</td>
</tr>
<tr>
<td>constructor</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
指定されていない場合、引数のないデフォルトコンストラクタが定義されている場合はそのコンストラクタを使います。<br/>
デフォルトのコンストラクタがない場合、コンストラクタの引数の数が1以上で、引数の型がすべてインターフェースのコンストラクタで最も引数の数が多いものを使います。<br/>
プロパティが明示的に指定されている場合は、それに従います。</td>
</tr>
<tr>
<td>property</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
指定されていない場合は、デフォルトのコンストラクタを使います。<br/>
型がインターフェースのプロパティを自動的にバインドします。</td>
</tr>
<tr>
<td>none</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br/>
プロパティが明示的に指定されている場合はそれに従います。</td>
</tr>
</table>
            <br/> 
            
            <p>詳しくは、<a href="#AutoConstructorInjectionEx">自動バインディング(コンストラクタ・インジェクション)</a>と<a href="#AutoSetterInjectionEx">自動バインディング(セッター・インジェクション)</a>を参照してください。</p>

            <a name="UseS2Container"><h3>コンポーネントでS2Containerを利用する</h3></a>
            <p>コンポーネントはS2Containerに依存しないことが望ましいのですが、コンポーネントによっては、S2Containerのメソッドを呼び出したい場合もあるでしょう。S2Container自身もcontainerという名前で、登録されているので、arg,propertyタグのボディでcontainerを指定することで、コンテナのインスタンスを取得できます。また、S2Container型のsetterメソッドを定義しておいて自動バインディングで設定することもできます。arg,propertyタグでcontainerを指定する場合は、次のようになります。</p>

<pre>
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.BarImpl&quot;&gt;
        &lt;arg&gt;container&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component class=&quot;examples.dicon.FooImpl&quot;&gt;
        &lt;property name=&quot;foo&quot;&gt;container&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>


            <a name="S2ContainerServlet"><h3>S2ContainerServlet</h3></a>
            <p>これまでは、Javaアプリケーションで、明示的にS2Containerを作成していましたが、Webアプリケーションの場合、誰がS2Containerを作成するのでしょうか。その目的のために次のクラスが用意されています。</p>
            <p>- org.seasar.framework.container.servlet#S2ContainerServlet</p>
            S2ContainerServletを使うためには、web.xmlに次の項目を記述します。<br/>src/org/seasar/framework/container/servlet/web.xmlに記述例もあります。

<pre>
&lt;servlet&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.seasar.framework.container.servlet.S2ContainerServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;configPath&lt;/param-name&gt;
        &lt;param-value&gt;app.dicon&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;s2servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/s2servlet&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre>

            <p>configPathでメインとなるS2Container定義のパスを指定します。定義ファイルはWEB-INF/classesにおきます。S2ContainerServletは、他のサーブレットよりもはやく起動されるようにload-on-startupタグを調整してください。S2ContainerServletが起動した後は、次のメソッドでS2Containerのインスタンスを取得することができます。</p>
            <p>- org.seasar.framework.container.factory.SingletonS2ContainerFactory#getContainer()</p>
            <p>また、S2Containerのライフサイクルは、S2ContainerServletと連動します。debugパラメータをtrueにすると、次のようにして、稼動中にS2Containerを再起動できます。xxxはWebアプリケーションのコンテキスト名です。</p>
			<pre>http://localhost:8080/xxx/s2servlet?command=restart
			</pre>
			<p>S2ContainerServletを使っている場合、ServletContextをservletContextという名前のコンポーネントとしてアクセスできるようになります。</p>

            <a name="app.dicon"><h3>app.diconの役割</h3></a>
            <p>すべてのS2Container定義のルートになる定義ファイルは、慣例でapp.diconという名前にします。app.diconにはコンポーネントの定義はしないようにしてください。通常はWEB-INF/classesにおくと良いでしょう。</p>

<pre>
&lt;components&gt;
    &lt;include path=&quot;examples/foo.dicon&quot;/&gt;
    &lt;include path=&quot;examples/bar.dicon&quot;/&gt;
          ： &lt;!-- 定義ファイルの数分記述します --&gt;
&lt;/components&gt;
</pre>

<a name="Aop"><h3>AOPの適用</h3></a>
<p>コンポーネントに<a href="aop.html">AOP</a>を適用することもできます。例えば、ArrayListに<a href="aop.html#TraceInterceptor">TraceInterceptor</a>を適用したい場合次のようにします。</p>

<pre>
&lt;components&gt;
    &lt;component name=&quot;traceInterceptor&quot;
               class=&quot;org.seasar.framework.aop.interceptors.TraceInterceptor&quot;/&gt;
    &lt;component class=&quot;java.util.ArrayList&quot;&gt;
        &lt;aspect&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
    &lt;component class=&quot;java.util.Date&quot;&gt;
        &lt;arg&gt;0&lt;/arg&gt;
        &lt;aspect pointcut=&quot;getTime, hashCode&quot;&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>aspectタグのボディで<a href="aop.html#Advice">Interceptor</a>の名前を指定します。pointcut属性にカンマ区切りで対象となるメソッド名を指定することができます。pointcut属性を指定しない場合は、コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。メソッド名には正規表現(JDK1.4のregex)も使えます。この定義を使うサンプルは次のようになります。</p>

<pre>
private static final String PATH =
    &quot;examples/dicon/Aop.dicon&quot;;
S2Container container = S2ContainerFactory.create(PATH);
List list = (List) container.getComponent(List.class);
list.size();
Date date = (Date) container.getComponent(Date.class);
date.getTime();
date.hashCode();
date.toString();
</pre> 

            <p>実行結果は次のようになります。</p>

<pre>
BEGIN java.util.ArrayList#size()
END java.util.ArrayList#size() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
BEGIN java.util.Date#hashCode()
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
END java.util.Date#hashCode() : 0
BEGIN java.util.Date#getTime()
END java.util.Date#getTime() : 0
</pre>

<a name="Meta">
<h3>メタデータ</h3>
</a>
<p>components、component、arg、propertyタグにメタデータ<a href="aop.html"></a>を指定することもできます。metaタグはメタデータを指定したいタグの子タグに指定します。例えば、componentsタグにメタデータを指定したい場合次のようにします。</p>

<pre>&lt;components&gt;
    &lt;meta name=&quot;aaa&quot;&gt;111&lt;/meta&gt;
&lt;/components&gt;
</pre>
<p>components、component、arg、propertyタグに指定したメタデータの情報は、S2Container、ComponentDef、ArgDef、PropertyDefで定義されている次のメソッドで取得することが出来ます。</p>
<ul>
<li>public int getMetaDefSize()</li>
<li>public MetaDef getMetaDef(int index)</li>
<li>public MetaDef getMetaDef(String name)</li>
<li>public MetaDef[] getMetaDefs(String name)</li>
</ul>

<a name="request">
<h3>リクエストの自動バインディング</h3>
</a>
<p>コンポーネントに対して、HttpServletRequestを自動的にバインディングすることが出来ます。そのためには、コンポーネントに、setRequest(HttpServletRequest request)のメソッドを定義します。そうすると、S2Containerが自動的にリクエストを設定します。また、次のようにFilterをweb.xmlに定義する必要があります。</p>
<pre>&lt;web-app&gt;
<br>	&lt;filter&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;filter-class&gt;org.seasar.framework.container.filter.S2ContainerFilter&lt;/filter-class&gt;<br>    &lt;/filter&gt;<br>    <br>    &lt;filter-mapping&gt;<br>        &lt;filter-name&gt;s2filter&lt;/filter-name&gt;<br>        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br>    &lt;/filter-mapping&gt;<br>&lt;/web-app&gt;
</pre>
<p>同様にHttpServletResponse、HttpSessionもsetterメソッドを定義するだけで、自動バインディングすることが出来ます。また、S2ContainerFilterを使うと、HttpServletRequest、HttpServletResponse、HttpSessionをそれぞれrequest、response、sessionという名前のコンポーネントとしてアクセスできるようになります。</p>
<a name="DefReference">
<h2>S2Container定義タグリファレンス</h2></a>

<a name="DOCTYPE"><h3>DOCTYPE</h3></a>
<p>DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;hello&quot; class=&quot;examples.dicon.HelloConstructorInjection&quot;&gt;
        &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <a name="componentsTag"><h3>componentsタグ(必須)</h3></a>
            <p>ルートのタグになります。</p>
            <a name="namespaceAttr"><h4>namespace属性(任意)</h4></a>
            <p><a href="#Namespace">名前空間</a>を指定することができます。Javaの識別子として使えるものにします</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components namespace=&quot;hoge&quot;&gt;
    ...
&lt;/components&gt;
</pre>

            <a name="includeTag"><h3>includeタグ(任意)</h3></a>
            <p>分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。</p>
            <a name="pathAttr"><h4>path属性(必須)</h4></a>
            <p>定義ファイルのパスを指定することができます。CLASSPATHで指定されているディレクトリをルートとする設定ファイルの絶対パスです。例えば、WEB-INF/classes/aaa.dicon の場合は aaa.dicon に、WEB-INF/classes/aaa/bbb/ccc.dicon の場合は aaa/bbb/ccc.dicon になりますセパレータは、WindowsでもUnixでも/です。componentタグの前に記述する必要があります。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;include path=&quot;aaa/bbb/ccc.dicon&quot; /&gt;
&lt;/components&gt;
</pre>

            <a name="componentTag"><h3>componentタグ(任意)</h3></a>
            <p>コンポーネントを定義します。</p>
            <a name="classAttr"><h4>class属性(任意)</h4></a>
            <p>クラスの完全限定名を指定します。ボディで、<a href="#ognlExpr">OGNL式</a>を使ってコンポーネントを指定した場合は、class属性を省略することができます。OGNL式を使った場合にclass属性を指定すると、型チェックを行います。</p>
            <a name="componentTag.nameAttr"><h4>name属性(任意)</h4></a>
            <p>名前を指定することもできます。Javaの識別子として使えるものにします。詳しくは、<a href="#getComponent">コンポーネントの取得</a>を参照してください。</p>
            <a name="instanceAttr"><h4>instance属性(任意)</h4></a>
            <p>S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは、<a href="#InstanceMode">インスタンス管理</a>を参照してください。</p>
            <a name="autoBindingAttr"><h4>autoBinding属性(任意)</h4></a>
            <p>S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。</p>

            <a name="argTag"><h3>argタグ(任意)</h3></a>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。記述した順番でコンストラクタに渡されます。
            <a href="#initMethodTag">initMethodタグ</a>、<a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。記述した順番でメソッドに渡されます。
            引数として渡される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>

            <a name="propertyTag"><h3>propertyタグ(任意)</h3></a>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>
            <a name="propertyTag.nameAttr"><h4>name属性(必須)</h4></a>
            <p>プロパティ名を指定します。</p>
			
			<a name="metaTag"><h3>metaタグ(任意)</h3></a>
            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディで、<a href="#ognlExpr">OGNL式</a>を使うか、子タグで、<a href="#componentTag">componentタグ</a>を使います。</p>
            <a name="propertyTag.nameAttr">
<h4>name属性(任意)</h4>
</a>
            <p>メタ名を指定します。</p>

            <a name="initMethodTag"><h3>initMethodタグ(任意)</h3></a>
            <p><a href="#componentTag">componentタグ</a>の子タグとして使います。引数は、子タグで、<a href="#argTag">argタグ</a>を使います。name属性を書かずに、<a href="#ognlExpr">OGNL式</a>を使って、コンポーネントのメソッドを呼び出すこともできます。initMethodタグが定義されているコンポーネント自身を表す#self、System.outを表す#out、System.errを表す#errがinitMethodタグ内だけで有効なオブジェクトとして使えます。</p>
            <a name="initMethodTag.nameAttr"><h4>name属性(任意)</h4></a>
            <p>メソッド名を指定します。</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;#self.put(&quot;aaa&quot;, 111)&lt;/initMethod&gt;
        &lt;initMethod&gt;#out.println(&quot;Hello&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <a name="destroyMethodTag"><h3>destroyMethodタグ(任意)</h3></a>
            <p>initMethodタグと同様です。</p>

            <a name="aspectTag"><h3>aspectタグ(任意)</h3></a>
            <p>アスペクトをコンポーネントに組み込みます。詳しくは、S2AOPの<a href="aop.html#aspectTag">aspectタグ</a>の説明を参照してください。</p>

            <a name="descriptionTag"><h3>descriptionタグ(任意)</h3></a>

            <p><a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。</p>

            <a name="ognlExpr"><h3>OGNL式</h3></a>
            <p>S2Containerでは、式言語として<a href="http://www.ognl.org/">OGNL</a>を利用しています。XMLの中で、文字列で記述した内容(式)をJavaのオブジェクトに変換するためのものだと思って間違いないと思います。

            <ul>
            <li>文字列は、&quot;hoge&quot;のように&quot;で囲みます。</li>
            <li>charは、'a'のように'で囲みます。</li>
            <li>数値は、123のようにそのまま記述します。</li>
            <li>論理値は、true,falseのようにそのまま記述します。</li>
            <li>new java.util.Date(0)のようにクラスの完全限定名でコンストラクタを呼び出すことができます。</li>
            <li> @java.lang.Math@max(1, 2)のようにstaticなメソッドを呼び出した結果を参照することができます。</li>
            <li>@java.lang.String@classのようにクラスを参照できます。</li>
            <li>hoge.toString()のようにコンポーネントのメソッドを呼び出した結果を参照することができます。この例は、どこかでhogeという名前のコンポーネントが定義されているという前提です。</li>
            </ul>
            詳しくは、<a href="http://www.ognl.org/2.6.7/Documentation/html/LanguageGuide/index.html">OGNLのマニュアル</a>を参照してください。<br/>
            <br/>

            <a name="Example"><h2>Example</h2></a>
            <p>以下のサンプルを実行する場合は、<a href="http://homepage3.nifty.com/seasar/setup.html">セットアップ</A>を行う必要があります。</p>

            <a name="ConstructorInjectionEx"><h3>コンストラクタ・インジェクション</h3></a>
            <p>コンストラクタ・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。</p>

        <ul>
            <li type="circle">インターフェース(Hello.java)</li>
            <li type="circle">実装クラス(HelloConstructorInjection.java)</li>
            <li type="circle">diconファイル(HelloConstructorInjection.dicon)</li>
            <li type="circle">実行クラス(HelloConstructorInjectionClient.java)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">showMessage()を定義します。</li>
        </ul>
            <p>先ず最初はインターフェースを考えます。インターフェースと実装を分離することで、コンポーネントの利用者は、インターフェースを知っていれば実装のことは知らなくても済むようになります。また、テストの時には実装をモックに置き換えることで簡単にテストできるようになります。</p>

<pre>
package examples.dicon;

public interface Hello {

    public void showMessage();
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">引数がString型のコンストラクタを定義します。</li>
            <li type="circle">showMessage()を実装します。</li>
        </ul>
            <p>次はいよいよ実装です。コンストラクタでメッセージを受け取り、showMessage()で受け取ったメッセージを出力します。</p>

<pre>
package examples.dicon;

public class HelloConstructorInjection implements Hello {

    private String message;
    
    public HelloConstructorInjection(String message) {
        this.message = message;
    }
    
    public void showMessage() {
        System.out.println(message);
    }
}
</pre> 

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle"><a href="#componentTag">componentタグ</a>でコンポーネントを定義します。</li>
            <li type="circle">componentタグの子タグの<a href="#argTag">argタグ</a>でコンストラクタの引数値を定義します。</li>
        </ul>

             <p>メッセージをコンポーネントに設定するのは、S2Containerの仕事です。定義ファイルに基づいてコンポーネントを組み立てます。<br/><br/>examples/dicon/HelloConstructorInjection.dicon</p>
             

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component name=&quot;hello&quot; class=&quot;examples.dicon.HelloConstructorInjection&quot;&gt;
        &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory.create(String path)を呼び出してS2Containerを作成します</a>。</li>
            <li type="circle">getComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
package examples.dicon;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class HelloConstructorInjectionClient {

    private static final String PATH =
        &quot;examples/dicon/HelloConstructorInjection.dicon&quot;;
        
    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        Hello hello = (Hello) container.getComponent(Hello.class);
        hello.showMessage();
        
        Hello hello2 = (Hello) container.getComponent(&quot;hello&quot;);
        hello2.showMessage();
    }
}
</pre>

            <h5>実行結果</h5>
            <p>argタグで指定した文字列が正しく表示されていることが確認できます。</p>
<pre>
Hello World!
Hello World!
</pre>
            <p>この演習は、seasar2/src/examples/dicon以下に用意されています。</p>

            <a name="SetterInjectionEx"><h3>セッター・インジェクション</h3></a>
            <p>セッター・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。</p>

        <ul>
            <li type="circle">インターフェース(Hello.java)</li>
            <li type="circle">実装クラス(HelloSetterInjection.java)</li>
            <li type="circle">diconファイル(HelloSetterInjection.dicon)</li>
            <li type="circle">実行クラス(HelloSetterInjectionClient.java)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">showMessage()を定義します。</li>
        </ul>
            <p>インターフェースはコンストラクタ・インジェクションの場合と同じです。プロパティに対するゲッター・メソッド、セッター・メソッドを定義する必要はありません。なぜなら、Dependency Injectionするのにコンストラクタを使うのかセッター・メソッドを使うのかは実装の問題だからです。 </p>

<pre>
package examples.dicon;

public interface Hello {

    public void showMessage();
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">セッター・メソッド(setMessage)を定義します。</li>
            <li type="circle">showMessage()を実装します。</li>
        </ul>

            <p>次は実装です。セッター・メソッドでメッセージを受け取り、showMessage()で受け取ったメッセージを出力します。</p>

<pre>
package examples.dicon;

public class HelloSetterInjection implements Hello {

    private String message;
    
    public HelloSetterInjection() {
    }
    
    public void setMessage(String message) {
        this.message = message;
    }

    public void showMessage() {
        System.out.println(message);
    }
}
</pre> 

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle">componentタグでコンポーネントを定義します。</li>
            <li type="circle">componentタグの子タグの<a href="#propertyTag">propertyタグ</a>でコンポーネントのプロパティ値を定義します。</li>
        </ul>

           <p>examples/dicon/HelloSetterInjection.dicon</p>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.HelloSetterInjection&quot;&gt;
        &lt;property name=&quot;message&quot;&gt;&quot;Hello World!&quot;&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle">S2ContainerFactory.create(String path)を呼び出してS2Containerを作成します。</li>
            <li type="circle">getComponent()を使用して、S2Containerからコンポーネントを取り出します。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
package examples.dicon;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class HelloSetterInjectionClient {

    private static final String PATH =
        &quot;examples/dicon/HelloSetterInjection.dicon&quot;;
        
    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        Hello hello = (Hello) container.getComponent(Hello.class);
        hello.showMessage();
    }
}
</pre>

            <h5>実行結果</h5>
            <p>propertyタグで指定した文字列が正しく表示されていることが確認できます。</p>
<pre>
Hello World!
</pre>

            <p>この演習は、seasar2/src/examples/dicon以下に用意されています。</p>

            <a name="MethodInjectionEx"><h3>メソッド・インジェクション</h3></a>
            <p>メソッド・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。</p>

        <ul>
            <li type="circle">インターフェース(Hello.java)</li>
            <li type="circle">実装クラス(HelloMethodInjection.java)</li>
            <li type="circle">diconファイル(HelloMethodInjection.dicon)</li>
            <li type="circle">実行クラス(HelloMethodInjectionClient.java)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">showMessage()を定義します。</li>
        </ul>
            <p>追加のメソッドを複数回呼び出すようなケースが代表的な使い方ですが、今回の演習では、インターフェースはコンストラクタ・インジェクションの場合と同じにしました。 </p>

<pre>
package examples.dicon;

public interface Hello {

    public void showMessage();
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">addMessage()を定義します。</li>
            <li type="circle">showMessage()を実装します。</li>
        </ul>
             <p>次は実装です。addMessage(String message)でメッセージを複数回追加して、showMessage()で受け取ったメッセージを出力します。</p>

<pre>
package examples.dicon;

public class HelloMethodInjection implements Hello {

    private StringBuffer buf = new StringBuffer();
    
    public HelloMethodInjection() {
    }
    
    public void addMessage(String message) {
        this.buf.append(message);
    }

    public void showMessage() {
        System.out.println(buf.toString());
    }
}
</pre>

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle">componentタグでコンポーネントを定義します。</li>
            <li type="circle">componentタグの子タグの<a href="#initMethodTag">initMethodタグ</a>でコンポーネントのメソッドの引数値を定義します。</li>
        </ul>
            

            <p>先ずは、argタグを使ってaddMessage(String message)に&quotHello &quotを指定します。<br/>次にOGNL式を使ってaddMessage(String message)に&quotWorld！&quotを指定します。<br/><br/>examples/dicon/HelloMethodInjection.dicon</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;examples.dicon.HelloMethodInjection&quot;&gt;
        &lt;initMethod name=&quot;addMessage&quot;&gt;
            &lt;arg&gt;&quot;Hello &quot;&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;#self.addMessage(&quot;World!&quot;)&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle">S2ContainerFactory.create(String path)を呼び出してS2Containerを作成します。</li>
            <li type="circle">getComponent()を使用して、S2Containerからコンポーネントを取り出します。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
package examples.dicon;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class HelloMethodInjectionClient {

    private static final String PATH =
        &quot;examples/dicon/HelloMethodInjection.dicon&quot;;
        
    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        Hello hello = (Hello) container.getComponent(Hello.class);
        hello.showMessage();
    }
}
</pre>

            <h5>実行結果</h5>
            <p>initMethodタグで指定した文字列が正しく表示されていることが確認できます。</p>
<pre>
Hello World!
</pre>
            <p>この演習は、seasar2/src/examples/dicon以下に用意されています。</p>


            <a name="AutoConstructorInjectionEx"><h3>自動バインディング(コンストラクタ・インジェクション)</h3></a>
            <p>自動バインディングでメッセージを表示してみましょう。作成するファイルは以下のとおりです。</p>
        <ul>
            <li type="circle">インターフェース(Hello.java)</li>
            <li type="circle">インターフェースの実装クラス(AutoHelloConstructorInjection.java)</li>
            <li type="circle">diconファイル(AutoHelloConstructorInjection.dicon)</li>
            <li type="circle">実行クラス(AutoHelloConstructorInjectionClient.java)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">showMessage()を定義します。</li>
        </ul>

<pre>
package examples.dicon.autobinding;

public interface Hello {

    public void showMessage();
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">引数がMapのコンストラクタを定義します。</li>
            <li type="circle">showMessage()を実装します。</li>
        </ul>
            <p>コンストラクタでMapを受け取り、showMessage()でhelloをキーとしてMapから値を取得して出力します。</p>

<pre>
package examples.dicon.autobinding;

import java.util.Map;

public class AutoHelloConstructorInjection implements Hello {

    private Map map;
    
    public AutoHelloConstructorInjection(Map map) {
        this.map = map;
    }
    
    public void showMessage() {
        System.out.println(map.get(&quot;hello&quot;));
    }
}
</pre> 

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle"><a href="#componentTag">componentタグ</a>でjava.util.Mapの実装クラスであるjava.util.HashMapをコンポーネント定義します。</li>
            <li type="circle">componentタグの子タグである<a href="#initMethodTag">initMethodタグ</a>でHashMapにキーとして"hello"、値として"Hello World!"を定義します。</li>
            <li type="circle">componentタグでAutoHelloConstructorInjectionをコンポーネント定義します。autoBinding属性にautoを指定します。<br/>演習であるため auto を明示的に指定していますが、autoBinding属性のデフォルト値であるため本来は省略します。</li>
        </ul>

             <p>AutoHelloConstructorInjectionには、argタグが定義されていないことに注目してください。コンストラクタ・インジェクションを行う場合、argタグを定義する必要がありますが、S2Container内にMapの実装クラスが登録されていれば、S2Containerがコンテナ内を検索して自動的に引数を設定します。ただし、引数の型がインターフェースでない場合、自動バインディングはできません。<br/><br/>examples/dicon/autobinding/AutoHelloConstructorInjection.dicon</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;hello&quot;&lt;/arg&gt;
            &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;

    &lt;component autoBinding=&quot;auto&quot; 
               class=&quot;examples.dicon.autobinding.AutoHelloConstructorInjection&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory.create(String path)を呼び出してS2Containerを作成します</a>。</li>
            <li type="circle">getComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
package examples.dicon.autobinding;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class AutoHelloConstructorInjectionClient {

    private static final String PATH =
        &quot;examples/dicon/autobinding/AutoHelloConstructorInjection.dicon&quot;;
        
    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        Hello hello = (Hello) container.getComponent(Hello.class);
        hello.showMessage();
    }
}
</pre>

            <h5>実行結果</h5>
            <p>HashMapの値が表示されていることから、自動的にコンストラクタの引数を設定していることが確認できます。</p>
<pre>
Hello World!
</pre>
            <p>この演習は、seasar2/src/examples/dicon/autobinding以下に用意されています。</p>

            <a name="AutoSetterInjectionEx"><h3>自動バインディング(セッター・インジェクション)</h3></a>
            <p>自動バインディングでメッセージを表示してみましょう。作成するファイルは以下のとおりです。</p>
        <ul>
            <li type="circle">インターフェース(Hello.java)</li>
            <li type="circle">インターフェースの実装クラス(AutoHelloSetterInjection.java)</li>
            <li type="circle">diconファイル(AutoHelloSetterInjection.dicon)</li>
            <li type="circle">実行クラス(AutoHelloSetterInjectionClient.java)</li>
        </ul>

            <h5>インターフェースの作成</h5>
        <ul>
            <li type="circle">showMessage()を定義します。</li>
        </ul>

<pre>
package examples.dicon.autobinding;

public interface Hello {

    public void showMessage();
}
</pre>

            <h5>実装クラスの作成</h5>

        <ul>
            <li type="circle">引数がMapのコンストラクタを定義します。</li>
            <li type="circle">showMessage()を実装します。</li>
        </ul>
            <p>setMessage(Map map)でMapを受け取り、showMessage()でhelloをキーとしてMapから値を取得して出力します。</p>

<pre>
package examples.dicon.autobinding;

import java.util.Map;

public class AutoHelloSetterInjection implements Hello {

    private Map map;
    
    public AutoHelloSetterInjection() {
    }
    
    public void setMessage(Map map) {
        this.map = map;
    }

    public void showMessage() {
        System.out.println(map.get("hello"));
    }
}
</pre> 

            <h5>diconファイルの作成</h5>

        <ul>
            <li type="circle"><a href="#componentTag">componentタグ</a>でjava.util.Mapの実装クラスであるjava.util.HashMapをコンポーネント定義します。</li>
            <li type="circle">componentタグの子タグである<a href="#initMethodTag">initMethodタグ</a>でHashMapにキーとして"hello"、値として"Hello World!"を定義します。</li>
            <li type="circle">componentタグでAutoHelloSetterInjectionをコンポーネント定義します。autoBinding属性にautoを指定します。<br/>演習であるため auto を明示的に指定していますが、autoBinding属性のデフォルト値であるため本来は省略します。</li>
        </ul>

             <p>AutoHelloSetterInjectionには、propertyタグが定義されていないことに注目してください。セッター・インジェクションを行う場合、propertyタグで任意のプロパティを定義する必要がありますが、S2Container内にMapの実装クラスが登録されていれば、S2Containerがコンテナ内を検索して自動的にプロパティを設定します。ただし、プロパティの型がインターフェースでない場合、自動バインディングはできません。<br/><br/>examples/dicon/autobinding/AutoHelloSetterInjection.dicon</p>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;Shift_JIS&quot;?&gt;
&lt;!DOCTYPE components PUBLIC &quot;-//SEASAR//DTD S2Container//EN&quot;
&quot;http://www.seasar.org/dtd/components.dtd&quot;&gt;
&lt;components&gt;
    &lt;component class=&quot;java.util.HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;hello&quot;&lt;/arg&gt;
            &lt;arg&gt;&quot;Hello World!&quot;&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;

    &lt;component autoBinding=&quot;auto&quot; 
               class=&quot;examples.dicon.autobinding.AutoHelloSetterInjection&quot;/&gt;
&lt;/components&gt;
</pre>

            <h5>実行クラスの作成</h5>

        <ul>
            <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory.create(String path)を呼び出してS2Containerを作成します</a>。</li>
            <li type="circle">getComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
            <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
        </ul>

<pre>
package examples.dicon.autobinding;

import org.seasar.framework.container.S2Container;
import org.seasar.framework.container.factory.S2ContainerFactory;

public class AutoHelloSetterInjectionClient {

    private static final String PATH =
        &quot;examples/dicon/autobinding/AutoHelloSetterInjection.dicon&quot;;
        
    public static void main(String[] args) {
        S2Container container = S2ContainerFactory.create(PATH);
        Hello hello = (Hello) container.getComponent(Hello.class);
        hello.showMessage();
    }
}
</pre>

            <h5>実行結果</h5>
            <p>HashMapの値が表示されていることから、自動的にプロパティを設定していることが確認できます。</p>
<pre>
Hello World!
</pre>

            <p>この演習は、seasar2/src/examples/dicon/autobinding以下に用意されています。</p>

            <br/>
            <br/>
            <!-- document end --><!-- don't edit start -->
</td>
<td width="18"><img height="16" width="18" src="images/spacer.gif" alt=""></td>
</tr><tr>
<td width="18"><img height="30" width="18" src="images/spacer.gif" alt=""></td>
<td width="744"><img height="30" width="744" src="images/spacer.gif" alt=""></td>
<td width="18"><img height="16" width="18" src="images/spacer.gif" alt=""></td></tr><tr>
<td width="18"><img height="14" width="18" src="images/spacer.gif" alt=""></td>
<td width="744" class="copyright">&copy; Copyright The Seasar Project and the others 2004, all rights reserved.</td>
<td width="18"><img height="16" width="18" src="images/spacer.gif" alt=""></td>
</tr></table>
<td class="backright" align="left" valign="top">&nbsp;</td></tr><tr>
<td class="backunder" align="left"  valign="top" width="780" height="14">&nbsp;</td>
<td class="backcorner" align="left" valign="top" height="14">&nbsp;</td>
</tr></table></body>
<!-- don't edit end -->
</html>
